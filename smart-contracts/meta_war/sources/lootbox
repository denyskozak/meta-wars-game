module meta_war::lootbox {
    use sui::object::{Self, UID};
    use sui::random;
    use sui::tx_context::{Self, TxContext};
    use sui::transfer;
    use sui::vector;
    use sui::coin;
    use sui::option;
    use meta_war::coin::{Self as mw_coin, COIN};

    /// ---------- capability -------------------------------------------------
    public struct LootBoxAdminCap has key { id: UID }

    /// Создать capability и зафиксировать “админа”.
    /// Вызывать **один раз** в деплой-транзакции.
    public fun init(ctx: &mut TxContext): LootBoxAdminCap {
        transfer::public_transfer(cap, tx_context::sender(ctx));
        return cap;
    }

    /// ---------- NFT --------------------------------------------------------
    public struct Skin  has key { id: UID, kind: u8 }      // 1-3
    public struct Medal has key { id: UID }
    public struct StaffFoo has key { id: UID }
    public struct StaffBar has key { id: UID }
    public struct EpicToken has key { id: UID }

    /// ---------- Loot-box ---------------------------------------------------
    public struct LootBox has key { id: UID, quality: u8 }

    const COMMON: u8 = 0;
    const RARE: u8 = 1;
    const EPIC: u8 = 2;

    /// чеканить коробку качества common (по умолчанию)
    /// требуются права администратора
    public fun create(
        cap : &mut LootBoxAdminCap,
        ctx : &mut TxContext
    ): LootBox {
        create_common(cap, ctx)
    }

    /// чеканить common коробку
    public fun create_common(
        _cap : &mut LootBoxAdminCap,
        ctx  : &mut TxContext
    ): LootBox {
        LootBox { id: object::new(ctx), quality: COMMON }
    }

    /// чеканить rare коробку
    public fun create_rare(
        _cap : &mut LootBoxAdminCap,
        ctx  : &mut TxContext
    ): LootBox {
        LootBox { id: object::new(ctx), quality: RARE }
    }

    /// чеканить epic коробку
    public fun create_epic(
        _cap : &mut LootBoxAdminCap,
        ctx  : &mut TxContext
    ): LootBox {
        LootBox { id: object::new(ctx), quality: EPIC }
    }

    /// открыть коробку в зависимости от её качества
    /// * `lb`     — сама коробка (сжигается)
    /// * `tc`     — TreasuryCap ваших монет
    public fun open(
        lb    : LootBox,
        tc    : &mut coin::TreasuryCap<COIN>,
        _owned: vector<u8>,
        ctx   : &mut TxContext,
    ) {
        if (lb.quality == COMMON) {
            open_common(lb, tc, ctx)
        } else if (lb.quality == RARE) {
            open_rare(lb, tc, ctx)
        } else {
            open_epic(lb, tc, ctx)
        }
    }

    fun open_common(lb: LootBox, tc: &mut coin::TreasuryCap<COIN>, ctx: &mut TxContext) {
        let amount = (random::rand_u64(ctx) % 3) + 1;         // 1..3
        let coins  = coin::mint(tc, amount, ctx);
        transfer::public_transfer(coins, tx_context::sender(ctx));
        object::delete_object(lb);
    }

    fun open_rare(lb: LootBox, tc: &mut coin::TreasuryCap<COIN>, ctx: &mut TxContext) {
        let amount = (random::rand_u64(ctx) % 6) + 3;         // 3..8
        let coins  = coin::mint(tc, amount, ctx);
        transfer::public_transfer(coins, tx_context::sender(ctx));
        maybe_mint_staff(ctx);
        object::delete_object(lb);
    }

    fun open_epic(lb: LootBox, tc: &mut coin::TreasuryCap<COIN>, ctx: &mut TxContext) {
        let amount = (random::rand_u64(ctx) % 3) + 8;         // 8..10
        let coins  = coin::mint(tc, amount, ctx);
        transfer::public_transfer(coins, tx_context::sender(ctx));
        maybe_mint_staff(ctx);
        let et = EpicToken { id: object::new(ctx) };
        transfer::public_transfer(et, tx_context::sender(ctx));
        object::delete_object(lb);
    }

    fun maybe_mint_staff(ctx: &mut TxContext) {
        let r = random::rand_u64(ctx) % 100;
        if (r < 5) {
            let foo = StaffFoo { id: object::new(ctx) };
            transfer::public_transfer(foo, tx_context::sender(ctx));
        } else if (r < 10) {
            let bar = StaffBar { id: object::new(ctx) };
            transfer::public_transfer(bar, tx_context::sender(ctx));
        }
    }
}
